package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;



parser code {:

    //Connect to the lexer
    Lexer lexer;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";

    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Tabla Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = "Variables";
        tipo[1] = "Globales";
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);
    }


//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para buscar si existe un parametro
public boolean existParam(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Param") && symbol[1].equals(id)) {
            return true; // si encontró el parametro
        }
    }
    return false; //  no encontró el parametro
}

//Metodo que devuelve los tipos de los parametros de una funcion
public ArrayList<String> getFuncParamsTypes(List<String[]> tabla) {
    ArrayList<String> paramsTypes = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsTypes.add(symbol[2]);
        }
    }
    return paramsTypes;
}

//Metodo que devuelve los ids de los parametros de una funcion
public ArrayList<String> getFuncParamsIds(List<String[]> tabla) {
    ArrayList<String> paramsIds = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsIds.add(symbol[1]);
        }
    }
    return paramsIds;
}

    StringBuffer mipsCode = new StringBuffer(); // Para concatenar el código mips
    StringBuffer variables  = new StringBuffer(); // Para concatenar las variables
    int currentTemp = 0; // Para generar los temporales
    int floatTemp = 0; // Para generar los temporales de float

    int structs = 0; // Para generar las etiquetas de las estructuras de control
    int strings = 0; // Para generar las etiquetas de las cadenas
    int cantParams = 0; // Para saber la cantidad de parámetros de una función


public StringBuffer getmipsCode() { // Para obtener el código intermedio
    return  mipsCode;
}

public int getCurrentTemp() { 
    currentTemp = (currentTemp + 1) % 10;
    return currentTemp;
}
public int getPreviousTemp(int previous) { 
    return (currentTemp - previous + 10) % 10;

}

public int getFloatTemp() { 
    if (floatTemp == 31) {
        floatTemp = 0;
        return floatTemp;
    }
    else if (floatTemp == 12) {
        floatTemp = 13;
        return floatTemp;
    }
    else {
       return floatTemp++;
    }
}


:};




init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;
precedence left LPAREN;


start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}
          | FLOAT:n {: RESULT = n+":float"; :}
          | CHAR:n {: RESULT = n+":char"; :}
          | STRING:n {: RESULT = n+":string"; :}
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS:plus {: RESULT = plus; :}
| MINUS:minus {: RESULT = minus; :}
| TIMES:times {: RESULT = times; :}
| DIVIDE:divide {: RESULT = divide; :}
| MODULE:module {: RESULT = module; :}
| POWER:power {: RESULT = power; :};

operand ::= literal:n
{:
   
    String tipo = n.toString().split(":")[1];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){
        case "int":
            movInstr = "li ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
            break;

        case "float":
            movInstr = "li.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
            break;

        case "bool":
            movInstr = "li ";
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
            break;

        case "char":
            movInstr = "li ";
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
            break;

        case "string":
            variables.append("str_" + strings++ +": .asciiz "+ n.toString().split(":")[0] +"\n");
            movInstr = "la $t" + getCurrentTemp() + ", str_" + (strings-1) + "\n";
            lastRegister ="$t" + currentTemp;
            codigo = movInstr +":" + lastRegister + ":" + tipo;
            break;

        default:
            break;
    }

    
    RESULT = codigo;

:}

| IDENTIFIER:id
{:

    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "float":
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            break;

        case "bool":
            movInstr = "lw ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "char":
            movInstr = "lb ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "string":
            movInstr = "la ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", "+ id.toString() + ":" + lastRegister + ":" + tipo;
    RESULT = codigo;

:}

| callFunction:cf
{:
    String tipo = tablasDeSimbolos.get(cf.toString().split(":")[1]).get(0)[1];

    String movInstr = "";
    switch(tipo){
        case "int":
            movInstr = "lw $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1];
            break;
        case "float":
            movInstr = "l.s $f"+ getFloatTemp() +", return_"+cf.toString().split(":")[1] ;
            break;
        case "bool":
            movInstr = "lw $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            break;
        case "char":
            movInstr = "lb $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            break;
        case "string":
            movInstr = "la $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            break;
        default:
            break;
    }   
    String codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$t" + currentTemp + ":" + tipo;      

    RESULT = codigo;

:};


relationalOp ::= EQUALS:eq {: RESULT = eq; :}  | DIFFERENT:dif {: RESULT = dif; :}  | GREATER:gr {: RESULT = gr; :}
| LESS:less {: RESULT = less; :}  | GREATEREQUAL:gre {: RESULT = gre; :} | LESSEQUAL:leq {: RESULT = leq; :};

logicalOp ::= AND:and {: RESULT = and; :}  | OR:or {: RESULT = or; :} ;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n
{:

    RESULT = n;

:}
| MINUS literal:n

{:

    String tipo = n.toString().split(":")[1];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){
        case "int":
            movInstr = "li ";    
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "float":
            movInstr = "li.s ";
            lastRegister = "$f" + getFloatTemp();
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", -"+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
    RESULT = codigo;
:}

| IDENTIFIER:id INCREMENT
{:

    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ id.toString() + "\naddi " + lastRegister + ", " + lastRegister + ", 1\nsw " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo;
            break;
    
        case "float":
            String moveToRegister = "li.s $f" + getFloatTemp() + ", 1.0\n" ;
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister + ", "+ id.toString() + "\n" + moveToRegister + "add.s " + lastRegister + ", " + lastRegister + ", $f" + (floatTemp-2) + "\ns.s " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo;
            break;
    
        default:
            break;
    }

    RESULT = codigo;                

:}

| IDENTIFIER:id DECREMENT
{:

   String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ id.toString() + "\naddi " + lastRegister + ", " + lastRegister + ", -1\nsw " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo;
            break;
    
        case "float":
            String moveToRegister = "li.s $f" + getFloatTemp() + ", -1.0\n" ;
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister + ", "+ id.toString() + "\n" + moveToRegister + "add.s " + lastRegister + ", " + lastRegister + ", $f" + (floatTemp-2) + "\ns.s " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo;
            break;
    
        default:
            break;
    }

    RESULT = codigo;                

:}


| aritmeticExpression:e1 aritmeticOp:op aritmeticExpression:e2
{:
    //codigo mips
    String operand = op.toString(); 
    String opInstr = "";
    String codigo = "";
    String lastRegister = e1.toString().split(":")[1];
    String tipo = e1.toString().split(":")[2];
    switch(tipo){
        case "int":
            if (operand.equals("+")) {
                opInstr  = "add ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("-")) {
                opInstr  = "sub ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("*")) {
                opInstr  = "mul ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("/")) {
                opInstr  = "div ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("%")) {
                opInstr  = "div ";  
                String temp = "$t" + getCurrentTemp();  
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + " \nli " +temp+ ",0 \n"+  opInstr + lastRegister + "," + e2.toString().split(":")[1] +"\nmfhi "+ temp+ ":" + temp + ":" + tipo;
            } else if (operand.equals("^")) {
                String idFunc = currentHash;
                variables.append("ini_" +idFunc+"_pow_"+ ++structs +": .word "+ 0 +"\n");
                variables.append("res_" +idFunc+"_pow_"+ structs +": .word "+ 0 +"\n");
                
                String etiquetaIni= "\n" +idFunc+"_pow_"+ (structs) +":";
                String res= "\nsw " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\nlw $t"+getCurrentTemp() + ", res_" +idFunc+"_pow_"+ structs+ "\nsw $t"+getCurrentTemp() + ", ini_" +idFunc+"_pow_"+ structs+ "\n";
                String iniCont= "\nli $t" + getPreviousTemp(1) + ", 1";
                String multiplicacion = "sw $t"+getPreviousTemp(1) +  ", ini_" +idFunc+"_pow_"+ structs+ "\nmul "+ lastRegister + ", " + lastRegister + ", " + "$t"+(getPreviousTemp(2))+ "\nsw " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\n";
                
                String add="\nlw $t"+getPreviousTemp(1) + ", ini_" +idFunc+"_pow_"+ structs+ "\nadd $t"+getPreviousTemp(1) + ", $t"+getPreviousTemp(1) + ", 1\n";
                String saltoAfirmativo = "blt $t"+(getPreviousTemp(1)) + " , $t"+(getPreviousTemp(3)) + " , "+ idFunc + "_pow_"+ structs;
                String saltoNegativo = "\nb " + idFunc + "_pow_"+ structs + "_end";
                String etiquetaEnd = "\n"+ idFunc + "_pow_"+ structs + "_end:";
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]+iniCont + res+ etiquetaIni +"\n" + multiplicacion + add + saltoAfirmativo + saltoNegativo + etiquetaEnd+ ":"+ 
                lastRegister + ":" + tipo;

            }
            break;

        case "float":
            if(operand.equals("+"))
            {
                opInstr  = "add.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("-"))
            {
                opInstr  = "sub.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("*"))
            {
                opInstr  = "mul.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand. equals("/"))
            {
                opInstr  = "div.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("%"))
            {
                opInstr  = "div.s ";  
                String temp = "$f" + getFloatTemp();  
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + " \n"+  opInstr +lastRegister + ", "+ lastRegister + "," + e2.toString().split(":")[1] +
                "\nmflo "+ temp+ "\nmul.s " + temp + ", " + temp + ", " + e2.toString().split(":")[1] + "\nsub.s $f12 , " +lastRegister +"," +temp + ":" + "$f12:" + tipo;
            }
            else if(operand.equals("^"))
            {
                String idFunc = currentHash;
                variables.append("ini_" +idFunc+"_pow_"+ ++structs +": .word "+ 0 +"\n");
                variables.append("res_" +idFunc+"_pow_"+ structs +": .float "+ 0.0 +"\n");
                String etiquetaIni= "\n" +idFunc+"_pow_"+ (structs) +":\n";
                String res= "\ns.s " + lastRegister + ", res_" +idFunc+"_pow_"+ structs/*+ "\nlwc1 $f"+getCurrentTemp() + ", res_" +idFunc+"_pow_"+ structs+ "\n"*/;
                String multiplicacion = "mul.s "+ lastRegister + ", " + lastRegister + ", " + "$f"+(getPreviousTemp(1))+ "\nswc1 " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\n";
                String add="\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_pow_"+ structs+ "\nadd $t"+(getPreviousTemp(1)) + ", $t"+(getPreviousTemp(1)) + ", 1\n" 
                + "sw $t"+(getPreviousTemp(1)) + ", ini_" +idFunc+"_pow_"+ structs + "\n";
                String saltoAfirmativo = "blt $t"+(getPreviousTemp(1)) + " , $t"+(getPreviousTemp(2)) + " , "+ idFunc + "_pow_"+ structs;
                String saltoNegativo = "\nb " + idFunc + "_pow_"+ structs + "_end";
                String etiquetaEnd = "\n"+ idFunc + "_pow_"+ structs + "_end:";
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + res+ etiquetaIni +"\n" + multiplicacion + add + 
                saltoAfirmativo + saltoNegativo + etiquetaEnd+ ":"+ lastRegister + ":" + tipo;
                
                
            }
            break;
    }
    RESULT = codigo;
:}

| LPAREN aritmeticExpression:e1 RPAREN
{:

    RESULT = e1;
:};

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression:e1 relationalOp:op aritmeticExpression:e2
{:
    

   
:};

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression:e1
{:
    RESULT = e1;
:};

logicalExpression ::= logicalExpression:e1 logicalOp:op logicalExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+ getCurrentTemp() +" = " + temporale1 + op + "t"+(getPreviousTemp(2));

    RESULT = codigo;

:};
logicalExpression ::= LPAREN logicalExpression:e1 RPAREN
{:

    RESULT = e1;

:};
logicalExpression ::= NOT logicalExpression:e1
{:

    String codigo = e1.toString() + "\n" + "t"+getCurrentTemp() +" = !t"+(getPreviousTemp(2));
    RESULT = codigo;
:};

expression ::= aritmeticExpression:e
{:
    RESULT = e;
:}

| logicalExpression:e
{:
    RESULT = e;
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:

  //code mips
    String idFunc = currentHash;

    String inicio= currentHash +"_if_"+ structs++ +": \n";

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    String temporale2 = lineas[1]; // Obtiene el último temporal generado
    String operacionLogica1 = temporale1.split(":")[0].split("=")[1] ; // Obtiene el último temporal generado
    String operacionLogica2 = temporale2.split(":")[0].toString(); // Obtiene el último temporal generado
    String registro1 = temporale1.split(":")[1]; // Obtiene el último temporal generado
    String registro2 = temporale2.split(":")[1]; // Obtiene el último temporal generado
    String operador="";
    String comparador = "";

    Pattern patron = Pattern.compile("==|<|>|<=|>=|!=");
    Matcher matcher = patron.matcher(temporale1.split(":")[2].toString());
    if (matcher.find()) {
        operador = matcher.group();
        if (operador.equals("==")) {
            comparador = "beq ";
        } else if (operador.equals("<")) {
            comparador = "blt ";
        } else if (operador.equals(">")) {
            comparador = "bgt ";
        } else if (operador.equals("<=")) {
            comparador = "ble ";
        } else if (operador.equals(">=")) {
            comparador = "bge ";
        } else if (operador.equals("!=")) {
            comparador = "bne "; 
        }
        }

    String codigo = operacionLogica1.trim() +"\n"+operacionLogica2+"\n"+ comparador + registro1 + ", " + registro2 + ", " + idFunc + "_if_"+ (structs) + "_bloque\nb " 
    +idFunc + "_if_"+ (structs) + "_bloque_end"+ "\n" + idFunc + "_if_"+ (structs) + "_bloque: \n"+ st.toString() + "\nb " 
    +idFunc + "_if_"+ (structs) + "_end\n" + idFunc + "_if_"+ structs + "_bloque_end:"+
    "\n" + idFunc + "_if_"+ (structs) + "_end:";
    

    RESULT = codigo;


:};

if_else_struct ::= if_struct:if_strc ELSE BLOCKSTART statements:st BLOCKEND
{:

    //cod mips
    String idFunc = currentHash;
    String ifCode = if_strc.toString();

    //insertar codigo del else antes de la ultima linea de ifCode
    String[] lineas = ifCode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndIf = lineas[lineas.length - 1];

    String etiquetaElse = etiquetaEndIf.replace("end", "else")+"\n";
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:");

    ifCode = ifCode.substring(0, ifCode.lastIndexOf("\n")); // Elimina la última línea
 
    String codigo = ifCode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndIf;

    RESULT = codigo;

:};

while_struct ::= WHILE LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    String temporale2 = lineas[1]; // Obtiene el último temporal generado
    String operacionLogica1 = temporale1.split(":")[0].split("=")[1].trim() ; // Obtiene el último temporal generado
    String operacionLogica2 = temporale2.split(":")[0].toString(); // Obtiene el último temporal generado
    String registro1 = temporale1.split(":")[1]; // Obtiene el último temporal generado
    String registro2 = temporale2.split(":")[1]; // Obtiene el último temporal generado
    String operador="";
    String comparador = "";

    //moverme a antes de la expresion logica
    String etiquetaPrincipal = idFunc+"_while_"+ ++structs+":";
    String etiquetaCondicion = "\n" + idFunc + "_while_"+ structs + "_condition:\n" ;


    Pattern patron = Pattern.compile("==|<|>|<=|>=|!=");
    Matcher matcher = patron.matcher(temporale1.split(":")[2].toString());
    if (matcher.find()) {
        operador = matcher.group();
    if (operador.equals("==")) {
        comparador = "beq ";
    } else if (operador.equals("<")) {
        comparador = "blt ";
    } else if (operador.equals(">")) {
        comparador = "bgt ";
    } else if (operador.equals("<=")) {
        comparador = "ble ";
    } else if (operador.equals(">=")) {
        comparador = "bge ";
    } else if (operador.equals("!=")) {
        comparador = "bne ";
    }
    }
    String saltoAfirmativo =comparador + registro1 + ", " + registro2 + ", " + idFunc + "_while_"+ (structs) + "_bloque";
    String saltoNegativo = "\nb " + idFunc + "_while_"+ (structs) + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_while_"+ structs + "_bloque:\n";
    String statements = st.toString();
    String etiquetaBloqueEnd = "\nb "+ idFunc + "_while_"+ structs + "_condition\n"+ idFunc +
    "_while_"+ structs + "_bloque_end:" + "\n" + idFunc + "_while_"+ structs + "_end:";
    RESULT = etiquetaPrincipal + etiquetaCondicion + operacionLogica1 +"\n"+ operacionLogica2 + "\n" + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetaBloqueEnd;

:};

while_else_struct ::= while_struct:while_stc ELSE BLOCKSTART statements:st BLOCKEND
{:
    //cod 3d
    String idFunc = currentHash;
    String whilecode = while_stc.toString();

    //insertar codigo del else antes de la ultima linea de whilecode
    String[] lineas = whilecode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndWhile = lineas[lineas.length - 1];
    String etiquetaElse = etiquetaEndWhile.replace("end", "else")+"\n";
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:");
    whilecode = whilecode.substring(0, whilecode.lastIndexOf("\n"));

    String codigo = whilecode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndWhile;

    RESULT = codigo;

:};

for_range_struct ::= FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 COMMA aritmeticExpression:e3 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");
    String [] lineas3 = e3.toString().split("\n");
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado
    String  temporale3 = lineas3[lineas3.length - 1];
    temporale3 = temporale3.split(" = ")[0]; // Obtiene el último temporal generado

    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n";
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word"+ temporale1.split(":")[0].split(",")[1]+"\n");
    String operacion =e1.toString().split(":")[0];
    String operacion2 = operacion.toString().split("t")[1];
    String operacionLogica1 = e1.toString().split(":")[0]+ "\nsw $t" +operacion2.split(",")[0]+", "+ id.toString(); 
    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n");
    String operacionLogica2 = e2.toString().split(":")[0];
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word"+ temporale3.split(":")[0].split(",")[1]+"\n");
    String operacionLogica3 = e3.toString().split(":")[0];
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs;
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+ currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";
    String statements = st.toString();
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc";
    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+(currentTemp)+", $t"+(currentTemp)+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+(currentTemp) + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+(currentTemp) +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:";
    RESULT = etiquetaIni + operacionLogica1 + "\n" + operacionLogica2 + "\n" + operacionLogica3 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;


:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");

    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado

    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n";
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word"+ temporale1.split(":")[0].split(",")[1]+"\n");
    String operacion =e1.toString().split(":")[0];
    String operacion2 = operacion.toString().split("t")[1];
    String operacionLogica1 = e1.toString().split(":")[0]+ "\nsw $t" +operacion2.split(",")[0]+", "+ id.toString(); 
    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n");
    String operacionLogica2 = e2.toString().split(":")[0];
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word 1"+"\n");
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs;
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";
    String statements = st.toString();
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc";

    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+currentTemp+", $t"+currentTemp+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+currentTemp + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+currentTemp +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:";

    RESULT = etiquetaIni + operacionLogica1 + "\n" + operacionLogica2 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;
:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas2 = e1.toString().split("\n");  // Divide la cadena en líneas

    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n";
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word 0"+"\n");

    String etiquetaFin= "\ndata_Int fin_" +idFunc+"_for_"+ structs+ "\n";


    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n");
    String operacionLogica2 = e1.toString().split(":")[0];
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word 1"+"\n");
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs;
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";
    String statements = st.toString();
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc";

    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+currentTemp+", $t"+currentTemp+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+currentTemp + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+currentTemp +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:";


    RESULT = etiquetaIni + "\n" + operacionLogica2 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;

:};

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal:lit DOTS statements
{:
  //code 3d
    String codigo = ++structs+"case_"+lit.toString().split(":")[0]+":";

:};

case_statements ::= case_statement:cs{::};

case_statements ::= case_statements:css case_statement:cs
{:
    RESULT = css + "," + cs;
:};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:cs BLOCKEND
{::};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:types default_statement BLOCKEND
{:



:};

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar
{:

    //Agregar a la tabla de simbolos
    String[] symbol = new String[3];
    symbol[0] = "Variable";
    symbol[1] = idVar.toString();
    symbol[2] = t.toString();
    tablasDeSimbolos.get(currentHash).add(symbol);


    //Codigo MIPS
    switch(t.toString()){
        case "int":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(idVar.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(idVar.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(idVar.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }

    RESULT= t.toString()+":"+idVar.toString();

:};

decl ::= varIdentifier ENDLINE{:
    RESULT="";
:};

assignment ::= IDENTIFIER:id ASSIGN expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0];
    String lastRegister = e.toString().split(":")[1];
    String tipoExpr = e.toString().split(":")[2];

    String movInstr = "";

    switch(tipoExpr){
        case "int":
            movInstr = "sw ";    
            break;
        case "float":
            movInstr = "s.s ";
            break;
        case "bool":
            movInstr = "sw ";
            break;
        case "char":
            movInstr = "sb ";
            break;
        case "string": //revisar strings
            movInstr = "sb ";
            break;
        default:
            break;
    }

    String code = exprCode + "\n" + movInstr + lastRegister + ", " + id.toString();
    RESULT = code;

:};

decl_and_assignment ::= varIdentifier:vi ASSIGN expression:e ENDLINE
{:
    String exprCode = e.toString().split(":")[0];
    String lastRegister = e.toString().split(":")[1];
    String tipoExpr = e.toString().split(":")[2];
    String id = vi.toString().split(":")[1];

    String movInstr = "";

    switch(tipoExpr){
        case "int":
            movInstr = "sw ";    
            break;
        case "float":
            movInstr = "s.s ";
            break;
        case "bool":
            movInstr = "sw ";
            break;
        case "char":
            movInstr = "sb ";
            break;
        case "string": //revisar strings
            movInstr = "sb ";
            break;
        default:
            break;
    }

    String code = exprCode + "\n" + movInstr + lastRegister + ", " + id.toString();
    RESULT = code;

:};

readData ::= READ READSYMBOL IDENTIFIER:id ENDLINE
{:
    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){
        case "int":
            lastRegister = "$t" + getCurrentTemp();
            codigo = "li $v0, 5\nsyscall\nsw $v0 , "+ id.toString();
            break;

        case "float":
            lastRegister = "$f" + getFloatTemp();
            codigo = "li $v0, 6\nsyscall\ns.s" + lastRegister + ", "+ id.toString();
            break;

        default:
            break;
    }

    RESULT = codigo;

:};

printData ::= PRINT PRINTSYMBOL expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0];
    String lastRegister = e.toString().split(":")[1];
    String tipoExpr = e.toString().split(":")[2];
    String code = "";

    switch(tipoExpr){
        case "int":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "float":
            code = "li $v0, 2\n" + "mov.s $f12, " + lastRegister + "\n" + "syscall";
            break;

        case "bool":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "char":
            code = "li $v0, 11\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "string":
            code = "li $v0, 4\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        default:
            break;
    }

    RESULT = exprCode + "\n" + code;
:};


sendParameters ::= expression:e
{:

    String tipoExpr = e.toString().split(":")[2];
    String lastRegister = e.toString().split(":")[1];
    String codigo = "";

    switch(tipoExpr){
        case "int":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";   
            break;

        case "float":
            codigo = "s.s " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "bool":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "char":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "string":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        default:
            break;
    } 

    RESULT = e.toString().split(":")[0] + "\n" + codigo;
:}

| sendParameters:sp COMMA expression:e
{:
    String tipoExpr = e.toString().split(":")[2];
    String lastRegister = e.toString().split(":")[1];
    String codigo = "";

    switch(tipoExpr){
        case "int":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";   
            break;

        case "float":
            codigo = "s.s " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "bool":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "char":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "string":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        default:
            break;
    } 

    RESULT = sp.toString() + "\n" + e.toString().split(":")[0] + "\n" + codigo;

:};

callFunction ::= IDENTIFIER:id LPAREN sendParameters:sp  RPAREN
{:

    String sendParams = sp.toString();
    ArrayList<String> paramsIds = getFuncParamsIds(tablasDeSimbolos.get(id.toString()));
    String codigo = "";

    for (int i = 0; i< paramsIds.size(); i++){
       sendParams = sendParams.replace("param"+i, paramsIds.get(i));
    }

    codigo = sendParams + "jal "+id.toString()+ ":"+ id.toString();
    cantParams = 0;
    RESULT = codigo;

:};

callFunction ::= IDENTIFIER:id LPAREN RPAREN
{:
    String codigo = "jal "+id.toString()+ ":"+ id.toString();
    RESULT = codigo;

:};


callFunction_statement ::= callFunction:cf ENDLINE
{:
        RESULT = cf.toString().split(":")[0];
:};

return_statement ::= RETURN SEPARATOR expression:e ENDLINE
{:

    String codigo = e.toString().split(":")[0] + "\n";
    String move="";
    String tipo = e.toString().split(":")[2];
    String lastRegister = e.toString().split(":")[1];
    switch(tipo){
        case "int":
            variables.append("return_" +currentHash+": .word 0\n");
            move = "sw "+lastRegister+", return_" +currentHash;
            break;
        case "float":
            variables.append("return_" +currentHash+": .float 0.0\n");
            move = "s.s "+lastRegister+", return_" +currentHash;
            break;
        case "bool":
            variables.append("return_" +currentHash+": .word 0\n");
            move = "sw "+lastRegister+", return_" +currentHash;
            break;
        case "char":
            variables.append("return_" +currentHash+": .byte 0\n");
            move = "sb "+lastRegister+", return_" +currentHash;
            break;
        case "string":
            variables.append("return_" +currentHash+": .asciiz \"\"\n");
            move = "sb "+lastRegister+", return_" +currentHash;
            break;
        default :
            break;
    }

    RESULT = codigo+"\n"+move+ "\njr $ra" ;

:}
| RETURN ENDLINE
{:
   
    String codigo = "jr $ra";
    RESULT = codigo;

:}

;
break_statement ::= BREAK ENDLINE
{:

:};


statement ::=   decl:decl {: RESULT = decl; :}
| assignment:assig {: RESULT = assig; :}
| decl_and_assignment:dcla {: RESULT = dcla; :}
| readData:rd {: RESULT = rd; :}
| printData: pd {: RESULT = pd; :}
| return_statement:rtn {: RESULT = rtn; :}
| break_statement
| callFunction_statement:cfs {: RESULT = cfs; :}
| if_struct:if_str {: RESULT = if_str; :}
| if_else_struct:if_else {: RESULT = if_else; :}
| while_struct:ws {: RESULT = ws; :}
| while_else_struct:wel {: RESULT = wel; :}
| for_range_struct:fr {: RESULT = fr; :}
| switch_struct:ss {: RESULT = ss; :};

statements ::= statement:st
{:
    RESULT = st;
:};

statements ::= statements:sts statement:st
{:

    RESULT = sts + "\n" + st;

:};

/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam
{:
     
    switch(t.toString()){
        case "int":
            variables.append(idParam.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(idParam.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(idParam.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(idParam.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(idParam.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }
  
    //Agregar a la tabla de simbolos
    String[] symbol = new String[3];
    symbol[0] = "Parametro";
    symbol[1] = idParam.toString();
    symbol[2] = t.toString();
    tablasDeSimbolos.get(currentHash).add(symbol);
  
:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc
{:

    //  Definir el tipo de tabla
        String tipoTabla = "main";
        if (idFunc.toString().equals("main")){
        tipoTabla = "Tipo: main ";
        }
        else{
        tipoTabla = "Tipo: funcion ";
        }

    // Crear tabla de simbolos para la funcion
        currentHash = idFunc.toString();
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = tipoTabla;
        tipo[1] = t.toString();
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);

       //Codigo MIPS
        //currentTemp = 1;
        String codigo = idFunc.toString()+":\n";
        RESULT = codigo;


:};

function ::= functionIdentifier:fi LPAREN parameters RPAREN BLOCKSTART statements:st BLOCKEND
{:


    String cierreFuncion = "\nend_"+fi.toString();
    String code = fi.toString() + st.toString() + cierreFuncion ;
    RESULT = code;

:}
| functionIdentifier:fi LPAREN  RPAREN BLOCKSTART statements:st BLOCKEND
{:
   
    String cierreFuncion = "\nend_"+fi.toString();
    String code = fi.toString() + st.toString() + cierreFuncion;
    RESULT = code;

:};

functions ::= function: f {: RESULT = f; :};
functions ::= functions:fs function:f {: RESULT = fs.toString() + f.toString(); :};
functions ::= errors;


globalVariable ::=  decl:decl
{: 
    RESULT = decl; 
    
:}
| decl_and_assignment:dcla
{: 

    RESULT = dcla; 

:};

globalVariables ::= globalVariable: gv
{: 

    RESULT = gv; 
    
:}
| globalVariables:gvs globalVariable:gv
{: 
    
    RESULT = gvs.toString()+gv.toString(); 

:};


/** PUNTO DE ENTRADA **/
program ::= globalVariables
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");

:}

| functions:fs
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    String code = fs.toString();
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append(code);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");


:}

| globalVariables:gvs functions:fs
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    String code = fs.toString();
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append(code);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");

:};

error_recovery ::= ERROR_RECOVERY;
errors ::= error_recovery;
errors ::= errors error_recovery;