package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;




parser code {:

    //Connect to the lexer
    Lexer lexer;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";

    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Tabla Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = "Variables";
        tipo[1] = "Globales";
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);
    }


//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para buscar si existe un parametro
public boolean existParam(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Param") && symbol[1].equals(id)) {
            return true; // si encontró el parametro
        }
    }
    return false; //  no encontró el parametro
}

//Metodo que devuelve los tipos de los parametros de una funcion
public ArrayList<String> getFuncParamsTypes(List<String[]> tabla) {
    ArrayList<String> paramsTypes = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsTypes.add(symbol[2]);
        }
    }
    return paramsTypes;
}

    StringBuffer mipsCode = new StringBuffer(); // Para concatenar el código mips
    StringBuffer variables  = new StringBuffer(); // Para concatenar las variables
    int currentTemp = 0; // Para generar los temporales
    int floatTemp = 0; // Para generar los temporales de float

    int structs = 0; // Para generar las etiquetas de las estructuras de control
    int lastParam = 3; // Para saber el último parámetro de una función


public StringBuffer getmipsCode() { // Para obtener el código intermedio
    return  mipsCode;
}


:};




init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;
precedence left LPAREN;

start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}
          | FLOAT:n {: RESULT = n+":float"; :}
          | CHAR:n {: RESULT = n+":char"; :}
          | STRING:n {: RESULT = n+":string"; :}
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS:plus {: RESULT = plus; :}
| MINUS:minus {: RESULT = minus; :}
| TIMES:times {: RESULT = times; :}
| DIVIDE:divide {: RESULT = divide; :}
| MODULE:module {: RESULT = module; :}
| POWER:power {: RESULT = power; :};

operand ::= literal:n
{:
   
    String tipo = n.toString().split(":")[1];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){
        case "int":
            movInstr = "li ";    
            lastRegister = "$t" + currentTemp++;
            break;

        case "float":
            movInstr = "li.s ";
            lastRegister = "$f" + floatTemp++;
            break;

        case "bool":
            movInstr = "li ";
            lastRegister = "$t" + currentTemp++;
            break;

        case "char":
            movInstr = "li ";
            lastRegister = "$t" + currentTemp++;
            break;

        case "string":
            movInstr = "la ";
            lastRegister = "$t" + currentTemp++;
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;
    RESULT = codigo;

:}

| IDENTIFIER:id
{:

    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2];
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + currentTemp++;
            break;

        case "float":
            movInstr = "l.s ";
            lastRegister = "$f" + floatTemp++;
            break;

        case "bool":
            movInstr = "lw ";
            lastRegister = "$t" + currentTemp++;
            break;

        case "char":
            movInstr = "lb ";
            lastRegister = "$t" + currentTemp++;
            break;

        case "string":
            movInstr = "la ";
            lastRegister = "$t" + currentTemp++;
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", "+ id.toString() + ":" + lastRegister + ":" + tipo;
    RESULT = codigo;

:}

| callFunction:cf
{:
    RESULT = cf;

:};


relationalOp ::= EQUALS:eq {: RESULT = eq; :}  | DIFFERENT:dif {: RESULT = dif; :}  | GREATER:gr {: RESULT = gr; :}
| LESS:less {: RESULT = less; :}  | GREATEREQUAL:gre {: RESULT = gre; :} | LESSEQUAL:leq {: RESULT = leq; :};

logicalOp ::= AND:and {: RESULT = and; :}  | OR:or {: RESULT = or; :} ;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n
{:

    RESULT = n;

:}
| MINUS literal:n

{:
    //cod 3d
    String code = "t"+currentTemp++ + " = -"+n.toString().split(":")[0];
    RESULT = code;

:}

| IDENTIFIER:id INCREMENT
{:
     //cod 3d
    String tempId= "t"+currentTemp++;
    String tempPP1= "t"+currentTemp++;
    String tempPP2= "t"+currentTemp++;
    String codigo = tempId +" = "+ id + "\n" + tempPP1 +" = 1"+"\n"+tempPP2 +" = "+tempId+" + "+tempPP1+"\n"+id +" = "+tempPP2;
    RESULT = codigo;


:}

| IDENTIFIER:id DECREMENT
{:

    //cod 3d
    String tempId= "t"+currentTemp++;
    String tempPP1= "t"+currentTemp++;
    String tempPP2= "t"+currentTemp++;
    String codigo = tempId +" = "+ id + "\n" + tempPP1 +" = 1"+"\n"+tempPP2 +" = "+tempId+" - "+tempPP1+"\n"+id +" = "+tempPP2;
    RESULT = codigo;

:};


aritmeticExpression ::= aritmeticExpression:e1 aritmeticOp:op aritmeticExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+ currentTemp++ +" = " + temporale1 + op + "t"+(currentTemp-2);

    RESULT = codigo;

:};

aritmeticExpression ::= LPAREN aritmeticExpression:e1 RPAREN
{:

    RESULT = e1;
:};

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression:e1 relationalOp:op aritmeticExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+currentTemp++ +" = " + temporale1 + op + "t"+(currentTemp-2);

    RESULT = codigo;

:};

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression:e1
{:
    RESULT = e1;
:};

logicalExpression ::= logicalExpression:e1 logicalOp:op logicalExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+ currentTemp++ +" = " + temporale1 + op + "t"+(currentTemp-2);

    RESULT = codigo;

:};
logicalExpression ::= LPAREN logicalExpression:e1 RPAREN
{:

    RESULT = e1;

:};
logicalExpression ::= NOT logicalExpression:e1
{:

    String codigo = e1.toString() + "\n" + "t"+currentTemp++ +" = !t"+(currentTemp-2);
    RESULT = codigo;
:};

expression ::= aritmeticExpression:e
{:
    RESULT = e;
:}

| logicalExpression:e
{:
    RESULT = e;
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:

     //cod 3d

    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaPrincipal = idFunc+"_if_"+ ++structs+":\n";
    String operacionLogica = e1.toString();
    String saltoAfirmativo = "\nif " + temporale1 + " goto "+ idFunc + "_if_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_if_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_if_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

    String etiquetaBloqueEnd = "\n"+ idFunc + "_if_"+ structs + "_bloque_end:";
    String etiquetaEndIf = "\n"+ idFunc + "_if_"+ structs + "_end:";

    RESULT = etiquetaPrincipal + operacionLogica + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetaBloqueEnd + etiquetaEndIf;


:};

if_else_struct ::= if_struct:if_strc ELSE BLOCKSTART statements:st BLOCKEND
{:

    //cod 3d
    String idFunc = currentHash;
    String ifCode = if_strc.toString();

    //insertar codigo del else antes de la ultima linea de ifCode
    String[] lineas = ifCode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndIf = lineas[lineas.length - 1];
    String etiquetaElse = etiquetaEndIf.replace("end", "else")+"\n";
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:");
    ifCode = ifCode.substring(0, ifCode.lastIndexOf("\n"));

    String codigo = ifCode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndIf;

    RESULT = codigo;

:};

while_struct ::= WHILE LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;
    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaPrincipal = idFunc+"_while_"+ ++structs+":";
    String etiquetaCondicion = "\n" + idFunc + "_while_"+ structs + "_condition:\n" ;
    String operacionLogica = e1.toString();
    String saltoAfirmativo = "\nif " + temporale1 + " goto "+ idFunc + "_while_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_while_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_while_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

    String etiquetaBloqueEnd = "\ngoto "+ idFunc + "_while_"+ structs + "_condition\n"+ idFunc +
    "_while_"+ structs + "_bloque_end:" + "\n" + idFunc + "_while_"+ structs + "_end:";

    RESULT = etiquetaPrincipal + etiquetaCondicion + operacionLogica + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetaBloqueEnd;

:};

while_else_struct ::= while_struct:while_stc ELSE BLOCKSTART statements:st BLOCKEND
{:
    //cod 3d
    String idFunc = currentHash;
    String whilecode = while_stc.toString();

    //insertar codigo del else antes de la ultima linea de whilecode
    String[] lineas = whilecode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndWhile = lineas[lineas.length - 1];
    String etiquetaElse = etiquetaEndWhile.replace("end", "else")+"\n";
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:");
    whilecode = whilecode.substring(0, whilecode.lastIndexOf("\n"));

    String codigo = whilecode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndWhile;

    RESULT = codigo;

:};

for_range_struct ::= FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 COMMA aritmeticExpression:e3 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");
    String [] lineas3 = e3.toString().split("\n");
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado
    String  temporale3 = lineas3[lineas3.length - 1];
    temporale3 = temporale3.split(" = ")[0]; // Obtiene el último temporal generado

    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\ndata_Int ini_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica = e1.toString();

    String etiquetaIni2 = "\nini_" +idFunc+"_for_"+ structs + " = " + temporale1;

    String etiquetaFin= "\ndata_Int fin_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica2 = e2.toString();

    String etiquetaFin2 = "\nfin_" +idFunc+"_for_"+ structs + " = " + temporale2;

    String etiquetaStep= "\ndata_Int step_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica3 = e3.toString();

    String etiquetaStep2 = "\nstep_" +idFunc+"_for_"+ structs + " = " + temporale3;

    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n"
    + "t"+currentTemp++ +" = ini_" +idFunc+"_for_"+ structs +"\nt"+ currentTemp++ +" = fin_" +idFunc+"_for_"+ structs +"\nt" + currentTemp++
    + " = t"+(currentTemp-3)+" < t"+(currentTemp-2);
    String saltoAfirmativo = "\nif t"+(currentTemp-1) + " goto "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_for_"+ structs + "_bloque_end";
    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nt" + currentTemp++ + " ="+ "step_" +idFunc+"_for_"+ structs + "\nt"
    + currentTemp++ + "= ini_" +idFunc+"_for_"+ structs + "\nt" + currentTemp++ + " = t"+(currentTemp-2)+" + t"+(currentTemp-3)
    +"\nini_" +idFunc+"_for_"+ structs + " = t"+(currentTemp-1)+ "\ngoto "+ idFunc + "_for_"+ structs + "_condition";

    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

    String etiquetaBloqueEnd = "\ngoto "+ idFunc + "_for_"+ structs + "_inc\n"+ idFunc + "_for_"+ structs + "_bloque_end:";

    RESULT = etiquetaIni + operacionLogica + etiquetaIni2 + etiquetaFin + operacionLogica2 + etiquetaFin2 + etiquetaStep + operacionLogica3 + etiquetaStep2 +
    operacionLogica4 +saltoAfirmativo + saltoNegativo + etiqueteInc + etiquetaBloque + statements + etiquetaBloqueEnd;

:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 RPAREN BLOCKSTART statements:st BLOCKEND
{:
        String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");

    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\ndata_Int ini_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica = e1.toString();

    String etiquetaIni2 = "\nini_" +idFunc+"_for_"+ structs + " = " + temporale1;

    String etiquetaFin= "\ndata_Int fin_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica2 = e2.toString();

    String etiquetaFin2 = "\nfin_" +idFunc+"_for_"+ structs + " = " + temporale2;

    String etiquetaStep= "\ndata_Int step_" +idFunc+"_for_"+ structs+ "\nt" + currentTemp++ + " = 1";


    String etiquetaStep2 = "\nstep_" +idFunc+"_for_"+ structs + " = " + "t" + (currentTemp-1);

    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n"
    + "t"+currentTemp++ +" = ini_" +idFunc+"_for_"+ structs +"\nt"+ currentTemp++ +" = fin_" +idFunc+"_for_"+ structs +"\nt" + currentTemp++
    + " = t"+(currentTemp-3)+" < t"+(currentTemp-2);
    String saltoAfirmativo = "\nif t"+(currentTemp-1) + " goto "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_for_"+ structs + "_bloque_end";
    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nt" + currentTemp++ + " ="+ "step_" +idFunc+"_for_"+ structs + "\nt"
    + currentTemp++ + "= ini_" +idFunc+"_for_"+ structs + "\nt" + currentTemp++ + " = t"+(currentTemp-2)+" + t"+(currentTemp-3)
    +"\nini_" +idFunc+"_for_"+ structs + " = t"+(currentTemp-1)+ "\ngoto "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

    String etiquetaBloqueEnd = "\ngoto "+ idFunc + "_for_"+ structs + "_inc\n"+ idFunc + "_for_"+ structs + "_bloque_end:";

    RESULT = etiquetaIni + operacionLogica + etiquetaIni2 + etiquetaFin + operacionLogica2 + etiquetaFin2 + etiquetaStep  + etiquetaStep2 +
    operacionLogica4 +saltoAfirmativo + saltoNegativo +etiqueteInc+ etiquetaBloque + statements + etiquetaBloqueEnd;




:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
            String idFunc = currentHash;

    String[] lineas2 = e1.toString().split("\n");  // Divide la cadena en líneas



    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\ndata_Int ini_" +idFunc+"_for_"+ structs+ "\nt" + currentTemp++ + " = 1";

    String etiquetaIni2 = "\nini_" +idFunc+"_for_"+ structs + " = " + "t" + (currentTemp-1);

    String etiquetaFin= "\ndata_Int fin_" +idFunc+"_for_"+ structs+ "\n";

    String operacionLogica2 = e1.toString();

    String etiquetaFin2 = "\nfin_" +idFunc+"_for_"+ structs + " = " + temporale2;

    String etiquetaStep= "\ndata_Int step_" +idFunc+"_for_"+ structs+ "\nt" + currentTemp++ + " = 1";


    String etiquetaStep2 = "\nstep_" +idFunc+"_for_"+ structs + " = " + "t" + (currentTemp-1);

    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n"
    + "t"+currentTemp++ +" = ini_" +idFunc+"_for_"+ structs +"\nt"+ currentTemp++ +" = fin_" +idFunc+"_for_"+ structs +"\nt" + currentTemp++
    + " = t"+(currentTemp-3)+" < t"+(currentTemp-2);
    String saltoAfirmativo = "\nif t"+(currentTemp-1) + " goto "+ idFunc + "_for_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_for_"+ structs + "_bloque_end";
    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nt" + currentTemp++ + " ="+ "step_" +idFunc+"_for_"+ structs + "\nt"
    + currentTemp++ + "= ini_" +idFunc+"_for_"+ structs + "\nt" + currentTemp++ + " = t"+(currentTemp-2)+" + t"+(currentTemp-3)
    +"\nini_" +idFunc+"_for_"+ structs + " = t"+(currentTemp-1)+ "\ngoto "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

     String etiquetaBloqueEnd = "\ngoto "+ idFunc + "_for_"+ structs + "_inc\n"+ idFunc + "_for_"+ structs + "_bloque_end:";

    RESULT = etiquetaIni  + etiquetaIni2 + etiquetaFin + operacionLogica2 + etiquetaFin2 + etiquetaStep  + etiquetaStep2 +
    operacionLogica4 +saltoAfirmativo + saltoNegativo +etiqueteInc+ etiquetaBloque + statements + etiquetaBloqueEnd;

:};

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal:lit DOTS statements
{:
  //code 3d
    String codigo = ++structs+"case_"+lit.toString().split(":")[0]+":";

:};

case_statements ::= case_statement:cs{::};

case_statements ::= case_statements:css case_statement:cs
{:
    RESULT = css + "," + cs;
:};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:cs BLOCKEND
{::};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:types default_statement BLOCKEND
{:



:};

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar
{:

    //Agregar a la tabla de simbolos
    String[] symbol = new String[3];
    symbol[0] = "Variable";
    symbol[1] = idVar.toString();
    symbol[2] = t.toString();
    tablasDeSimbolos.get(currentHash).add(symbol);


    //Codigo MIPS
    switch(t.toString()){
        case "int":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(idVar.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(idVar.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(idVar.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }

    RESULT= t.toString()+" "+idVar.toString();

:};

decl ::= varIdentifier ENDLINE{:
    RESULT="";
:};

assignment ::= IDENTIFIER:id ASSIGN expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0];
    String lastRegister = e.toString().split(":")[1];
    String tipoExpr = e.toString().split(":")[2];

    String movInstr = "";

    switch(tipoExpr){
        case "int":
            movInstr = "sw ";    
            break;
        case "float":
            movInstr = "s.s ";
            break;
        case "bool":
            movInstr = "sw ";
            break;
        case "char":
            movInstr = "sb ";
            break;
        case "string": //revisar strings
            movInstr = "sb ";
            break;
        default:
            break;
    }

    String code = exprCode + "\n" + movInstr + lastRegister + ", " + id.toString();
    RESULT = code;

:};

decl_and_assignment ::= varIdentifier:vi ASSIGN expression:e1 ENDLINE
{:
 
    String code = vi.toString() + "\n" + e1.toString() + "\n" ;
    switch(vi.toString().split(" ")[0]){
        case "int":
            code += "sw $t"+(currentTemp-1)+", "+vi.toString().split(" ")[1]+"\n";
            break;
        case "float":
            code += "s.s $f"+(currentTemp-1)+", "+vi.toString().split(" ")[1]+"\n";
            break;
        case "bool":
            code += "sw $t"+(currentTemp-1)+", "+vi.toString().split(" ")[1]+"\n";
            break;
        case "char":
            code += "sb $t"+(currentTemp-1)+", "+vi.toString().split(" ")[1]+"\n";
            break;
        case "string":
            code += "sw $t"+(currentTemp-1)+", "+vi.toString().split(" ")[1]+"\n";
            break;
        default:
            break;
    }
    RESULT = code;

:};

readData ::= READ READSYMBOL IDENTIFIER:id ENDLINE
{:
    //cod 3d
    String codigo = "param "+id.toString()+"\nt"+currentTemp++ +" = call read, 1";
    RESULT = codigo;

:};

printData ::= PRINT PRINTSYMBOL expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0];
    String lastRegister = e.toString().split(":")[1];
    String tipoExpr = e.toString().split(":")[2];
    String code = "";

    switch(tipoExpr){
        case "int":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "float":
            code = "li $v0, 2\n" + "mov.s $f12, " + lastRegister + "\n" + "syscall";
            break;

        case "bool":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "char":
            code = "li $v0, 11\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "string":
            code = "li $v0, 4\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        default:
            break;
    }

    RESULT = exprCode + "\n" + code;
:};


sendParameters ::= expression:e
{:

    String tipoExpr = e.toString().split(":")[1];
    String lastRegister = e.toString().split(":")[0];

    String movInstr = "";
    String code = "";


    switch(tipoExpr){
        case "int":
            movInstr = "li";    
            break;
        case "float":
            movInstr = "li.s";
            break;
        case "bool":
            movInstr = "li";
            break;
        case "char":
            movInstr = "lb";
            break;
        case "string":
            movInstr = "la";
            break;
        default:
            break;
    } 

    switch(lastParam) {
        case 1:
            code = movInstr + " $a2, "+ lastRegister;
            lastParam = 2;
            break;
        case 2:
            code = movInstr + " $a3, "+ lastRegister;
            lastParam = 3;
            break;
        case 3:
            code = movInstr +" $a0, "+ lastRegister;
            lastParam = 0;
            break;
        case 0:
            code = movInstr + " $a1, "+ lastRegister;
            lastParam = 1;
            break;
        default:
            code = "addi $sp, $sp, -4" + "\n sw" + lastRegister + ", 0($sp)";
    }

    RESULT = code;
:}

| sendParameters:sp COMMA expression:e
{:

    String tipoExpr = e.toString().split(":")[1];
    String lastRegister = e.toString().split(":")[0];

    String movInstr = "";
    String code = "";


    switch(tipoExpr){
        case "int":
            movInstr = "li";    
            break;
        case "float":
            movInstr = "li.s";
            break;
        case "bool":
            movInstr = "li";
            break;
        case "char":
            movInstr = "lb";
            break;
        case "string":
            movInstr = "la";
            break;
        default:
            break;
    } 

    switch(lastParam) {
        case 1:
            code = movInstr + " $a2, "+ lastRegister;
            lastParam = 2;
            break;
        case 2:
            code = movInstr + " $a3, "+ lastRegister;
            lastParam = 3;
            break;
        case 3:
            code = movInstr +" $a0, "+ lastRegister;
            lastParam = 0;
            break;
        case 0:
            code = movInstr + " $a1, "+ lastRegister;
            lastParam = 1;
            break;
        default:
            code = "addi $sp, $sp, -4" + "\n sw" + lastRegister + ", 0($sp)";
    }

    RESULT = sp.toString() + "\n" + code;

:};

callFunction ::= IDENTIFIER:id LPAREN sendParameters:sp  RPAREN
{:

    String codigo = sp.toString() + "jal "+id.toString();
    RESULT = codigo;

:};

callFunction ::= IDENTIFIER:id LPAREN RPAREN
{:
    String codigo = "jal "+id.toString();
    RESULT = codigo;

:};


callFunction_statement ::= callFunction:cf ENDLINE
{:
        RESULT = cf;
:};

return_statement ::= RETURN SEPARATOR expression:e ENDLINE
{:

    String codigo = e.toString() + "\n" + "  jr $ra";
    RESULT = codigo;

:}
| RETURN ENDLINE
{:
   
    String codigo = "  jr $ra";
    RESULT = codigo;

:}

;
break_statement ::= BREAK ENDLINE
{:

:};


statement ::=   decl:decl {: RESULT = decl; :}
| assignment:assig {: RESULT = assig; :}
| decl_and_assignment:dcla {: RESULT = dcla; :}
| readData:rd {: RESULT = rd; :}
| printData: pd {: RESULT = pd; :}
| return_statement:rtn {: RESULT = rtn; :}
| break_statement
| callFunction_statement:cfs {: RESULT = cfs; :}
| if_struct:if_str {: RESULT = if_str; :}
| if_else_struct:if_else {: RESULT = if_else; :}
| while_struct:ws {: RESULT = ws; :}
| while_else_struct:wel {: RESULT = wel; :}
| for_range_struct:fr {: RESULT = fr; :}
| switch_struct:ss {: RESULT = ss; :};

statements ::= statement:st
{:
    RESULT = st;
:};

statements ::= statements:sts statement:st
{:

    RESULT = sts + "\n" + st;

:};

/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam
{:
     
    switch(t.toString()){
        case "int":
            variables.append(currentHash + "_" + idParam.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(currentHash + "_" + idParam.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(currentHash + "_" + idParam.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(currentHash + "_" + idParam.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(currentHash + "_" + idParam.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }
  
:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc
{:

    //  Definir el tipo de tabla
        String tipoTabla = "main";
        if (idFunc.toString().equals("main")){
        tipoTabla = "Tipo: main ";
        }
        else{
        tipoTabla = "Tipo: funcion ";
        }

    // Crear tabla de simbolos para la funcion
        currentHash = idFunc.toString();
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = tipoTabla;
        tipo[1] = t.toString();
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);

       //Codigo MIPS
        currentTemp = 1;
        String codigo = idFunc.toString()+":\n";
        RESULT = codigo;


:};

function ::= functionIdentifier:fi LPAREN parameters RPAREN BLOCKSTART statements:st BLOCKEND
{:


    String cierreFuncion = "\nend_"+fi.toString();
    String code = fi.toString() + st.toString() + cierreFuncion;
    RESULT = code;

:}
| functionIdentifier:fi LPAREN  RPAREN BLOCKSTART statements:st BLOCKEND
{:
   
    String cierreFuncion = "\nend_"+fi.toString();
    String code = fi.toString() + st.toString() + cierreFuncion;
    RESULT = code;

:};

functions ::= function: f {: RESULT = f; :};
functions ::= functions:fs function:f {: RESULT = fs.toString() + f.toString(); :};
functions ::= errors;


globalVariable ::=  decl:decl
{: 
    RESULT = decl; 
    
:}
| decl_and_assignment:dcla
{: 

    RESULT = dcla; 

:};

globalVariables ::= globalVariable: gv
{: 

    RESULT = gv; 
    
:}
| globalVariables:gvs globalVariable:gv
{: 
    
    RESULT = gvs.toString()+gv.toString(); 

:};


/** PUNTO DE ENTRADA **/
program ::= globalVariables
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");

:}

| functions:fs
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    String code = fs.toString();
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append(code);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");


:}

| globalVariables:gvs functions:fs
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    String code = fs.toString();
    mipsCode.append(dataSection);
    mipsCode.append(variables.toString());
    mipsCode.append(textSection);
    mipsCode.append(code);
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall");

:};

error_recovery ::= ERROR_RECOVERY;
errors ::= error_recovery;
errors ::= errors error_recovery;