package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;



parser code {:

    //Connect to the lexer
    Lexer lexer;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";

    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Tabla Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = "Variables";
        tipo[1] = "Globales";
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);
    }


//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para buscar si existe un parametro
public boolean existParam(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Param") && symbol[1].equals(id)) {
            return true; // si encontró el parametro
        }
    }
    return false; //  no encontró el parametro
}

//Metodo que devuelve los tipos de los parametros de una funcion
public ArrayList<String> getFuncParamsTypes(List<String[]> tabla) {
    ArrayList<String> paramsTypes = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsTypes.add(symbol[2]);
        }
    }
    return paramsTypes;
}

//Metodo que devuelve los ids de los parametros de una funcion
public ArrayList<String> getFuncParamsIds(List<String[]> tabla) {
    ArrayList<String> paramsIds = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsIds.add(symbol[1]);
        }
    }
    return paramsIds;
}

    StringBuffer mipsCode = new StringBuffer(); // Para concatenar el código mips
    StringBuffer variables  = new StringBuffer(); // Para concatenar las variables
    int currentTemp = 0; // Para generar los temporales
    int floatTemp = 0; // Para generar los temporales de float

    int structs = 0; // Para generar las etiquetas de las estructuras de control
    int strings = 0; // Para generar las etiquetas de las cadenas
    int cantParams = 0; // Para saber la cantidad de parámetros de una función


public StringBuffer getmipsCode() { // Para obtener el código intermedio
    return  mipsCode;
}

public int getCurrentTemp() { // Para obtener el temporal actual
    currentTemp = (currentTemp + 1) % 10;
    return currentTemp;
}
public int getPreviousTemp(int previous) { // Para obtener el temporal anterior
    return (currentTemp - previous + 10) % 10;

}

public int getFloatTemp() { // Para obtener el temporal actual de float
    floatTemp = (floatTemp + 1) % 31;
    return floatTemp;
}


:};




init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;
precedence left LPAREN;


start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}
          | FLOAT:n {: RESULT = n+":float"; :}
          | CHAR:n {: RESULT = n+":char"; :}
          | STRING:n {: RESULT = n+":string"; :}
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS:plus {: RESULT = plus; :}
| MINUS:minus {: RESULT = minus; :}
| TIMES:times {: RESULT = times; :}
| DIVIDE:divide {: RESULT = divide; :}
| MODULE:module {: RESULT = module; :}
| POWER:power {: RESULT = power; :};

operand ::= literal:n
{:
   
    String tipo = n.toString().split(":")[1]; // Obtiene el tipo del literal
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){//dependiendo del tipo del literal se genera el codigo mips
        case "int":
            movInstr = "li ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
            break;

        case "float":
            movInstr = "li.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;//se genera el codigo mips
            break;

        case "bool":
            movInstr = "li ";
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;//se genera el codigo mips
            break;

        case "char":
            movInstr = "li ";
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo;//se genera el codigo mips
            break;

        case "string":
            variables.append("str_" + strings++ +": .asciiz "+ n.toString().split(":")[0] +"\n"); //se agrega la variable
            movInstr = "la $t" + getCurrentTemp() + ", str_" + (strings-1) + "\n";
            lastRegister ="$t" + currentTemp;
            codigo = movInstr +":" + lastRegister + ":" + tipo;//se genera el codigo mips
            break;

        default:
            break;
    }

    
    RESULT = codigo; //se devuelve el codigo mips

:}

| IDENTIFIER:id
{:

    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2]; // Obtiene el tipo del identificador
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){ //dependiendo del tipo del identificador se genera el codigo mips
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "float":
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            break;

        case "bool":
            movInstr = "lw ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "char":
            movInstr = "lb ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "string":
            movInstr = "la ";
            lastRegister = "$t" + getCurrentTemp();
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", "+ id.toString() + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
    RESULT = codigo; //se devuelve el codigo mips

:}

| callFunction:cf
{:
    String tipo = tablasDeSimbolos.get(cf.toString().split(":")[1]).get(0)[1]; // Obtiene el tipo de la función

    String movInstr = "";
    String codigo = "";
    switch(tipo){ //dependiendo del tipo de la función se genera el codigo mips
        case "int":
            movInstr = "lw $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1]; 
            codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$t" + currentTemp + ":" + tipo;   //se genera el codigo mips  
            break;
        case "float":
            movInstr = "l.s $f"+ getFloatTemp() +", return_"+cf.toString().split(":")[1] ;
            codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$f" + floatTemp + ":" + tipo;   //se genera el codigo mips  
            break;
        case "bool":
            movInstr = "lw $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$t" + currentTemp + ":" + tipo;   //se genera el codigo mips  
            break;
        case "char":
            movInstr = "lb $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$t" + currentTemp + ":" + tipo;   //se genera el codigo mips  
            break;
        case "string":
            movInstr = "la $t"+ getCurrentTemp() +", return_"+cf.toString().split(":")[1] ;
            codigo = cf.toString().split(":")[0] + "\n" + movInstr + ":$t" + currentTemp + ":" + tipo;   //se genera el codigo mips  
            break;
        default:
            break;
    }   
    

    RESULT = codigo;

:};


relationalOp ::= EQUALS:eq {: RESULT = eq; :}  | DIFFERENT:dif {: RESULT = dif; :}  | GREATER:gr {: RESULT = gr; :}
| LESS:less {: RESULT = less; :}  | GREATEREQUAL:gre {: RESULT = gre; :} | LESSEQUAL:leq {: RESULT = leq; :};

logicalOp ::= AND:and {: RESULT = and; :}  | OR:or {: RESULT = or; :} ;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n
{:

    RESULT = n;

:}
| MINUS literal:n

{:

    String tipo = n.toString().split(":")[1]; // Obtiene el tipo del literal
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
     switch(tipo){ //dependiendo del tipo del literal se genera el codigo mips
        case "int":
            movInstr = "li ";    
            lastRegister = "$t" + getCurrentTemp();
            break;

        case "float":
            movInstr = "li.s ";
            lastRegister = "$f" + getFloatTemp();
            break;

        default:
            break;
    }

    codigo = movInstr + lastRegister+", -"+ n.toString().split(":")[0] + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
    RESULT = codigo;
:}

| IDENTIFIER:id INCREMENT
{:

    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2]; // Obtiene el tipo del identificador
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){ //dependiendo del tipo del identificador se genera el codigo mips
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ id.toString() + "\naddi " + lastRegister + ", " + lastRegister + ", 1\nsw " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
            break;
    
        case "float":
            String moveToRegister = "li.s $f" + getFloatTemp() + ", 1.0\n" ;
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister + ", "+ id.toString() + "\n" + moveToRegister + "add.s " + lastRegister + ", " + lastRegister + ", $f" + (floatTemp-2) + "\ns.s " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
            break;
    
        default:
            break;
    }

    RESULT = codigo;                

:}

| IDENTIFIER:id DECREMENT
{:

   String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2]; // Obtiene el tipo del identificador
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){ //dependiendo del tipo del identificador se genera el codigo mips
        case "int":
            movInstr = "lw ";    
            lastRegister = "$t" + getCurrentTemp();
            codigo = movInstr + lastRegister+", "+ id.toString() + "\naddi " + lastRegister + ", " + lastRegister + ", -1\nsw " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
            break;
    
        case "float":
            String moveToRegister = "li.s $f" + getFloatTemp() + ", -1.0\n" ;
            movInstr = "l.s ";
            lastRegister = "$f" + getFloatTemp();
            codigo = movInstr + lastRegister + ", "+ id.toString() + "\n" + moveToRegister + "add.s " + lastRegister + ", " + lastRegister + ", $f" + (floatTemp-2) + "\ns.s " + lastRegister + ", " + id.toString() + ":" + lastRegister + ":" + tipo; //se genera el codigo mips
            break;
    
        default:
            break;
    }

    RESULT = codigo;                

:}


| aritmeticExpression:e1 aritmeticOp:op aritmeticExpression:e2
{:
    //codigo mips
    String operand = op.toString();  // Obtiene el operando
    String opInstr = "";
    String codigo = "";
    String lastRegister = e1.toString().split(":")[1]; // Obtiene el último temporal generado
    String tipo = e1.toString().split(":")[2]; // Obtiene el tipo del último temporal generado
    switch(tipo){ //dependiendo del tipo del identificador se genera el codigo mips
        case "int":
            if (operand.equals("+")) {
                opInstr  = "add ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("-")) {
                opInstr  = "sub ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("*")) {
                opInstr  = "mul ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("/")) {
                opInstr  = "div ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;

            } else if (operand.equals("%")) {
                opInstr  = "div ";  
                String temp = "$t" + getCurrentTemp();  
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + " \nli " +temp+ ",0 \n"+  opInstr + lastRegister + "," + e2.toString().split(":")[1] +"\nmfhi "+ temp+ ":" + temp + ":" + tipo;
            } else if (operand.equals("^")) {
                String idFunc = currentHash;
                variables.append("ini_" +idFunc+"_pow_"+ ++structs +": .word "+ 0 +"\n"); //se agrega la variable inicializadora del ciclo
                variables.append("res_" +idFunc+"_pow_"+ structs +": .word "+ 0 +"\n");//se agrega la variable resultado del ciclo
                
                String etiquetaIni= "\n" +idFunc+"_pow_"+ (structs) +":"; //se genera la etiqueta inicial del ciclo
                String res= "\nsw " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\nlw $t"+getCurrentTemp() + ", res_" +idFunc+"_pow_"+ structs+ "\nsw $t"
                +getCurrentTemp() + ", ini_" +idFunc+"_pow_"+ structs+ "\n"; //se genera el codigo mips para guardar el resultado y la variable inicializadora del ciclo
                String iniCont= "\nli $t" + getPreviousTemp(1) + ", 1"; //se genera el codigo mips para inicializar el contador del ciclo
                String multiplicacion = "sw $t"+getPreviousTemp(1) +  ", ini_" +idFunc+"_pow_"+ structs+ "\nmul "+ lastRegister + ", " + lastRegister + ", " 
                + "$t"+(getPreviousTemp(2))+ "\nsw " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\n"; //se genera el codigo mips para multiplicar el resultado por el primer operando
                
                String add="\nlw $t"+getPreviousTemp(1) + ", ini_" +idFunc+"_pow_"+ structs+ "\nadd $t"+getPreviousTemp(1) + ", $t"+getPreviousTemp(1) + ", 1\n";//se genera el codigo mips para incrementar el contador del ciclo
                String saltoAfirmativo = "blt $t"+(getPreviousTemp(1)) + " , $t"+(getPreviousTemp(3)) + " , "+ idFunc + "_pow_"+ structs; //se genera el codigo mips para saltar al ciclo
                String saltoNegativo = "\nb " + idFunc + "_pow_"+ structs + "_end"; //se genera el codigo mips para saltar al final del ciclo
                String etiquetaEnd = "\n"+ idFunc + "_pow_"+ structs + "_end:"; //se genera la etiqueta final del ciclo
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]+iniCont + res+ etiquetaIni +"\n" + multiplicacion + add + saltoAfirmativo + saltoNegativo + etiquetaEnd+ ":"+ 
                lastRegister + ":" + tipo; //se genera el codigo mips

            }
            break;

        case "float": //dependiendo del tipo del identificador se genera el codigo mips
            if(operand.equals("+"))
            {
                opInstr  = "add.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("-"))
            {
                opInstr  = "sub.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("*"))
            {
                opInstr  = "mul.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand. equals("/"))
            {
                opInstr  = "div.s ";    
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0]  + "\n" + opInstr + lastRegister + ", " + lastRegister + "," + e2.toString().split(":")[1] + ":" + lastRegister + ":" + tipo;
            }
            else if(operand.equals("%"))
            {
                opInstr  = "div.s ";  
                String temp = "$f" + getFloatTemp();  
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + " \n"+  opInstr +lastRegister + ", "+ lastRegister + "," + e2.toString().split(":")[1] +
                "\nmflo "+ temp+ "\nmul.s " + temp + ", " + temp + ", " + e2.toString().split(":")[1] + "\nsub.s $f12 , " +lastRegister +"," +temp + ":" + "$f12:" + tipo;
            }
            else if(operand.equals("^"))
            {
                String idFunc = currentHash;
                variables.append("ini_" +idFunc+"_pow_"+ ++structs +": .word "+ 0 +"\n");
                variables.append("res_" +idFunc+"_pow_"+ structs +": .float "+ 0.0 +"\n");
                String etiquetaIni= "\n" +idFunc+"_pow_"+ (structs) +":\n";
                String res= "\ns.s " + lastRegister + ", res_" +idFunc+"_pow_"+ structs/*+ "\nlwc1 $f"+getCurrentTemp() + ", res_" +idFunc+"_pow_"+ structs+ "\n"*/;
                String multiplicacion = "mul.s "+ lastRegister + ", " + lastRegister + ", " + "$f"+(getPreviousTemp(1))+ "\nswc1 " + lastRegister + ", res_" +idFunc+"_pow_"+ structs+ "\n";
                String add="\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_pow_"+ structs+ "\nadd $t"+(getPreviousTemp(1)) + ", $t"+(getPreviousTemp(1)) + ", 1\n" 
                + "sw $t"+(getPreviousTemp(1)) + ", ini_" +idFunc+"_pow_"+ structs + "\n";
                String saltoAfirmativo = "blt $t"+(getPreviousTemp(1)) + " , $t"+(getPreviousTemp(2)) + " , "+ idFunc + "_pow_"+ structs;
                String saltoNegativo = "\nb " + idFunc + "_pow_"+ structs + "_end";
                String etiquetaEnd = "\n"+ idFunc + "_pow_"+ structs + "_end:";
                codigo = e1.toString().split(":")[0] + "\n" +  e2.toString().split(":")[0] + res+ etiquetaIni +"\n" + multiplicacion + add + 
                saltoAfirmativo + saltoNegativo + etiquetaEnd+ ":"+ lastRegister + ":" + tipo;
                
                
            }
            break;
    }
    RESULT = codigo;
:}

| LPAREN aritmeticExpression:e1 RPAREN
{:

    RESULT = e1;
:};

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression:e1 relationalOp:op aritmeticExpression:e2
{:
    

   
:};

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression:e1
{:
    RESULT = e1;
:};

logicalExpression ::= logicalExpression:e1 logicalOp:op logicalExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+ getCurrentTemp() +" = " + temporale1 + op + "t"+(getPreviousTemp(2)); //se genera el codigo mips

    RESULT = codigo;

:};
logicalExpression ::= LPAREN logicalExpression:e1 RPAREN
{:

    RESULT = e1;

:};
logicalExpression ::= NOT logicalExpression:e1
{:

    String codigo = e1.toString() + "\n" + "t"+getCurrentTemp() +" = !t"+(getPreviousTemp(2)); //se genera el codigo mips
    RESULT = codigo;
:};

expression ::= aritmeticExpression:e
{:
    RESULT = e;
:}

| logicalExpression:e
{:
    RESULT = e;
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:

  //code mips
    String idFunc = currentHash;

    String inicio= currentHash +"_if_"+ structs++ +": \n";

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    String temporale2 = lineas[1]; // Obtiene el último temporal generado
    String operacionLogica1 = temporale1.split(":")[0].split("=")[1] ; // Obtiene el último temporal generado
    String operacionLogica2 = temporale2.split(":")[0].toString(); // Obtiene el último temporal generado
    String registro1 = temporale1.split(":")[1]; // Obtiene el último temporal generado
    String registro2 = temporale2.split(":")[1]; // Obtiene el último temporal generado
    String operador="";
    String comparador = "";

    Pattern patron = Pattern.compile("==|<|>|<=|>=|!="); //se obtiene el operador de la expresion logica
    Matcher matcher = patron.matcher(temporale1.split(":")[2].toString()); //se obtiene el operador de la expresion logica
    if (matcher.find()) { //si hay operador
        operador = matcher.group(); //se obtiene el operador de la expresion logica
        if (operador.equals("==")) { //depende del operador se genera el codigo mips
            comparador = "beq ";
        } else if (operador.equals("<")) {
            comparador = "blt ";
        } else if (operador.equals(">")) {
            comparador = "bgt ";
        } else if (operador.equals("<=")) {
            comparador = "ble ";
        } else if (operador.equals(">=")) {
            comparador = "bge ";
        } else if (operador.equals("!=")) {
            comparador = "bne "; 
        }
        }

    String codigo = operacionLogica1.trim() +"\n"+operacionLogica2+"\n"+ comparador + registro1 + ", " + registro2 + ", " + idFunc + "_if_"+ (structs) + "_bloque\nb " 
    +idFunc + "_if_"+ (structs) + "_bloque_end"+ "\n" + idFunc + "_if_"+ (structs) + "_bloque: \n"+ st.toString() + "\nb " 
    +idFunc + "_if_"+ (structs) + "_end\n" + idFunc + "_if_"+ structs + "_bloque_end:"+
    "\n" + idFunc + "_if_"+ (structs) + "_end:"; //se genera el codigo mips
    

    RESULT = codigo;


:};

if_else_struct ::= if_struct:if_strc ELSE BLOCKSTART statements:st BLOCKEND
{:

    //cod mips
    String idFunc = currentHash;
    String ifCode = if_strc.toString();

    //insertar codigo del else antes de la ultima linea de ifCode
    String[] lineas = ifCode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndIf = lineas[lineas.length - 1];

    String etiquetaElse = etiquetaEndIf.replace("end", "else")+"\n";
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:");

    ifCode = ifCode.substring(0, ifCode.lastIndexOf("\n")); // Elimina la última línea
 
    String codigo = ifCode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndIf;

    RESULT = codigo;

:};

while_struct ::= WHILE LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    String temporale2 = lineas[1]; // Obtiene el último temporal generado
    String operacionLogica1 = temporale1.split(":")[0].split("=")[1].trim() ; // Obtiene el último temporal generado
    String operacionLogica2 = temporale2.split(":")[0].toString(); // Obtiene el último temporal generado
    String registro1 = temporale1.split(":")[1]; // Obtiene el último temporal generado
    String registro2 = temporale2.split(":")[1]; // Obtiene el último temporal generado
    String operador="";
    String comparador = "";

    //moverme a antes de la expresion logica
    String etiquetaPrincipal = idFunc+"_while_"+ ++structs+":"; //se genera la etiqueta principal del ciclo
    String etiquetaCondicion = "\n" + idFunc + "_while_"+ structs + "_condition:\n" ; //se genera la etiqueta de la condicion del ciclo


    Pattern patron = Pattern.compile("==|<|>|<=|>=|!="); //se obtiene el operador de la expresion logica
    Matcher matcher = patron.matcher(temporale1.split(":")[2].toString()); //se obtiene el operador de la expresion logica
    if (matcher.find()) { //si hay operador
        operador = matcher.group();//se obtiene el operador de la expresion logica
    if (operador.equals("==")) { //depende del operador se genera el codigo mips
        comparador = "beq ";
    } else if (operador.equals("<")) {
        comparador = "blt ";
    } else if (operador.equals(">")) {
        comparador = "bgt ";
    } else if (operador.equals("<=")) {
        comparador = "ble ";
    } else if (operador.equals(">=")) {
        comparador = "bge ";
    } else if (operador.equals("!=")) {
        comparador = "bne ";
    }
    }
    String saltoAfirmativo =comparador + registro1 + ", " + registro2 + ", " + idFunc + "_while_"+ (structs) + "_bloque"; //se genera el codigo mips para saltar al ciclo
    String saltoNegativo = "\nb " + idFunc + "_while_"+ (structs) + "_bloque_end"; //  se genera el codigo mips para saltar al final del ciclo
    String etiquetaBloque = "\n"+ idFunc + "_while_"+ structs + "_bloque:\n"; //se genera la etiqueta del bloque del ciclo
    String statements = st.toString();
    String etiquetaBloqueEnd = "\nb "+ idFunc + "_while_"+ structs + "_condition\n"+ idFunc +
    "_while_"+ structs + "_bloque_end:" + "\n" + idFunc + "_while_"+ structs + "_end:"; //se genera la etiqueta del final del ciclo
    RESULT = etiquetaPrincipal + etiquetaCondicion + operacionLogica1 +"\n"+ operacionLogica2 + "\n" + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetaBloqueEnd;

:};

while_else_struct ::= while_struct:while_stc ELSE BLOCKSTART statements:st BLOCKEND
{:
    //cod 3d
    String idFunc = currentHash; // Obtiene el tipo del identificador
    String whilecode = while_stc.toString();

    //insertar codigo del else antes de la ultima linea de whilecode
    String[] lineas = whilecode.split("\n");  // Divide la cadena en líneas
    String etiquetaEndWhile = lineas[lineas.length - 1];
    String etiquetaElse = etiquetaEndWhile.replace("end", "else")+"\n"; //se genera la etiqueta del else
    String etiquetaElseEnd = etiquetaElse.replace(":", "_end:"); //se genera la etiqueta del final del else
    whilecode = whilecode.substring(0, whilecode.lastIndexOf("\n")); // Elimina la última línea

    String codigo = whilecode + "\n" + etiquetaElse + st.toString() + "\n" + etiquetaElseEnd+ etiquetaEndWhile; //se genera el codigo mips

    RESULT = codigo;

:};

for_range_struct ::= FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 COMMA aritmeticExpression:e3 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");
    String [] lineas3 = e3.toString().split("\n");
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado
    String  temporale3 = lineas3[lineas3.length - 1];
    temporale3 = temporale3.split(" = ")[0]; // Obtiene el último temporal generado

    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n"; //se genera la etiqueta inicial del ciclo
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word"+ temporale1.split(":")[0].split(",")[1]+"\n"); //se agrega la variable inicializadora del ciclo
    String operacion =e1.toString().split(":")[0]; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String operacion2 = operacion.toString().split("t")[1]; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String operacionLogica1 = e1.toString().split(":")[0]+ "\nsw $t" +operacion2.split(",")[0]+", "+ id.toString();  // se genera el codigo mips para guardar la variable inicializadora del ciclo
    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n"); //se agrega la variable final del ciclo
    String operacionLogica2 = e2.toString().split(":")[0]; //se genera el codigo mips para guardar la variable final del ciclo
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word"+ temporale3.split(":")[0].split(",")[1]+"\n"); //se agrega la variable del paso del ciclo
    String operacionLogica3 = e3.toString().split(":")[0]; //se genera el codigo mips para guardar la variable del paso del ciclo
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+ currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque"; //se genera el codigo mips para saltar al ciclo
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end"; //se genera el codigo mips para saltar al final del ciclo
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n"; //se genera la etiqueta del bloque del ciclo
    String statements = st.toString(); //se genera el codigo mips para guardar el resultado y la variable inicializadora del ciclo
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc"; //se genera el codigo mips para saltar al incremento del ciclo
    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+(currentTemp)+", $t"+(currentTemp)+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+(currentTemp) + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+(currentTemp) +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition"; //se genera el codigo mips para incrementar el contador del ciclo
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:"; //se genera la etiqueta del final del ciclo
    RESULT = etiquetaIni + operacionLogica1 + "\n" + operacionLogica2 + "\n" + operacionLogica3 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;


:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String [] lineas2 = e2.toString().split("\n");

    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado

    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n"; //se genera la etiqueta inicial del ciclo
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word"+ temporale1.split(":")[0].split(",")[1]+"\n"); //se agrega la variable inicializadora del ciclo
    String operacion =e1.toString().split(":")[0]; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String operacion2 = operacion.toString().split("t")[1]; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String operacionLogica1 = e1.toString().split(":")[0]+ "\nsw $t" +operacion2.split(",")[0]+", "+ id.toString();  // se genera el codigo mips para guardar la variable inicializadora del ciclo
    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n");    //se agrega la variable final del ciclo
    String operacionLogica2 = e2.toString().split(":")[0]; //se genera el codigo mips para guardar la variable final del ciclo
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word 1"+"\n");  //se agrega la variable del paso del ciclo
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque"; //se genera el codigo mips para saltar al ciclo
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end"; //se genera el codigo mips para saltar al final del ciclo
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n"; //se genera la etiqueta del bloque del ciclo
    String statements = st.toString();
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc";   //se genera el codigo mips para saltar al incremento del ciclo

    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+currentTemp+", $t"+currentTemp+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+currentTemp + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+currentTemp +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:"; //se genera la etiqueta del final del ciclo

    RESULT = etiquetaIni + operacionLogica1 + "\n" + operacionLogica2 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;
:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:
    String idFunc = currentHash;

    String[] lineas2 = e1.toString().split("\n");  // Divide la cadena en líneas

    String temporale2 = lineas2[lineas2.length - 1];
    temporale2 = temporale2.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaIni= idFunc+"_for_"+ ++structs+":\n"; //se genera la etiqueta inicial del ciclo
    variables.append("ini_" +idFunc+"_for_"+ structs +": .word 0"+"\n"); //se agrega la variable inicializadora del ciclo

    String etiquetaFin= "\ndata_Int fin_" +idFunc+"_for_"+ structs+ "\n"; //se agrega la variable final del ciclo


    variables.append("\nfin_" +idFunc+"_for_"+ structs +": .word"+ temporale2.split(":")[0].split(",")[1]+"\n");
    String operacionLogica2 = e1.toString().split(":")[0]; //se genera el codigo mips para guardar la variable final del ciclo
    variables.append("\nstep_" +idFunc+"_for_"+ structs+": .word 1"+"\n");
    String operacionLogica4 = "\n" + idFunc + "_for_"+ structs + "_condition:\n" + "lw $t"+getCurrentTemp() +" , ini_" +idFunc+"_for_"+ structs +"\nlw $t"+ getCurrentTemp() 
    +" , fin_" +idFunc+"_for_"+ structs; //se genera el codigo mips para guardar la variable inicializadora del ciclo
    String saltoAfirmativo = "\nblt $t"+(getPreviousTemp(1)) + " , $t"+currentTemp + " , "+ idFunc + "_for_"+ structs + "_bloque"; //se genera el codigo mips para saltar al ciclo
    String saltoNegativo = "\nb " + idFunc + "_for_"+ structs + "_bloque_end"; //se genera el codigo mips para saltar al final del ciclo
    String etiquetaBloque = "\n"+ idFunc + "_for_"+ structs + "_bloque:\n"; //se genera la etiqueta del bloque del ciclo
    String statements = st.toString(); 
    String etiquetagoto = "\nb "+ idFunc + "_for_"+ structs + "_inc"; //se genera el codigo mips para saltar al incremento del ciclo

    String etiqueteInc= "\n"+ idFunc + "_for_"+ structs + "_inc: \nlw $t" + getCurrentTemp() + " , "+ "step_" +idFunc+"_for_"+ structs + 
    "\nlw $t"+getCurrentTemp() + ", ini_" +idFunc+"_for_"+ structs + 
    "\nadd $t"+currentTemp+", $t"+currentTemp+" , $t"+(getPreviousTemp(1))+
    "\nsw $t"+currentTemp + ", ini_" +idFunc+"_for_"+ structs + "\nsw $t"+currentTemp +","+id.toString() +"\nb "+ idFunc + "_for_"+ structs + "_condition";
    String etiquetaBloqueEnd = "\n"+ idFunc + "_for_"+ structs + "_bloque_end:"; //se genera la etiqueta del final del ciclo


    RESULT = etiquetaIni + "\n" + operacionLogica2 + "\n" + operacionLogica4 + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetagoto + etiqueteInc + etiquetaBloqueEnd;

:};

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal:lit DOTS statements
{:
  //code 3d
    String codigo = ++structs+"case_"+lit.toString().split(":")[0]+":"; //se genera el codigo mips

:};

case_statements ::= case_statement:cs{::};

case_statements ::= case_statements:css case_statement:cs
{:
    RESULT = css + "," + cs;
:};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:cs BLOCKEND
{::};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:types default_statement BLOCKEND
{:



:};

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar
{:

    //Agregar a la tabla de simbolos
    String[] symbol = new String[3]; //se crea el arreglo para agregar a la tabla de simbolos
    symbol[0] = "Variable"; //se agrega el tipo de simbolo
    symbol[1] = idVar.toString(); //se agrega el identificador
    symbol[2] = t.toString(); //se agrega el tipo de dato
    tablasDeSimbolos.get(currentHash).add(symbol); //se agrega el simbolo a la tabla de simbolos


    //Codigo MIPS
    switch(t.toString()){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(idVar.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(idVar.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(idVar.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(idVar.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }

    RESULT= t.toString()+":"+idVar.toString(); //se genera el codigo mips

:};

decl ::= varIdentifier ENDLINE{:
    RESULT="";
:};

assignment ::= IDENTIFIER:id ASSIGN expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0]; //se obtiene el codigo mips de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    String tipoExpr = e.toString().split(":")[2]; //se obtiene el tipo de dato de la expresion

    String movInstr = "";

    switch(tipoExpr){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            movInstr = "sw ";    
            break;
        case "float":
            movInstr = "s.s ";
            break;
        case "bool":
            movInstr = "sw ";
            break;
        case "char":
            movInstr = "sb ";
            break;
        case "string": //revisar strings
            movInstr = "sb ";
            break;
        default:
            break;
    }

    String code = exprCode + "\n" + movInstr + lastRegister + ", " + id.toString(); //se genera el codigo mips
    RESULT = code;

:};

decl_and_assignment ::= varIdentifier:vi ASSIGN expression:e ENDLINE
{:
    String exprCode = e.toString().split(":")[0]; //se obtiene el codigo mips de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    String tipoExpr = e.toString().split(":")[2]; //se obtiene el tipo de dato de la expresion
    String id = vi.toString().split(":")[1]; //se obtiene el identificador

    String movInstr = "";

    switch(tipoExpr){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            movInstr = "sw ";    
            break;
        case "float":
            movInstr = "s.s ";
            break;
        case "bool":
            movInstr = "sw ";
            break;
        case "char":
            movInstr = "sb ";
            break;
        case "string": //revisar strings
            movInstr = "sb ";
            break;
        default:
            break;
    }

    String code = exprCode + "\n" + movInstr + lastRegister + ", " + id.toString(); //se genera el codigo mips
    RESULT = code;

:};

readData ::= READ READSYMBOL IDENTIFIER:id ENDLINE
{:
    String tipo = getSymbol(tablasDeSimbolos.get(currentHash), id.toString())[2]; //se obtiene el tipo de dato de la variable
    String movInstr = "";
    String codigo = "";
    String lastRegister = "";
    
    switch(tipo){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            lastRegister = "$t" + getCurrentTemp();
            codigo = "li $v0, 5\nsyscall\nsw $v0 , "+ id.toString();
            break;

        case "float":
            lastRegister = "$f" + getFloatTemp();
            codigo = "li $v0, 6\nsyscall\ns.s" + lastRegister + ", "+ id.toString();
            break;

        default:
            break;
    }

    RESULT = codigo;

:};

printData ::= PRINT PRINTSYMBOL expression:e ENDLINE
{:

    String exprCode = e.toString().split(":")[0]; //se obtiene el codigo mips de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    String tipoExpr = e.toString().split(":")[2]; //se obtiene el tipo de dato de la expresion
    String code = "";

    switch(tipoExpr){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "float":
            code = "li $v0, 2\n" + "mov.s $f12, " + lastRegister + "\n" + "syscall";
            break;

        case "bool":
            code = "li $v0, 1\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "char":
            code = "li $v0, 11\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        case "string":
            code = "li $v0, 4\n" + "move $a0, " + lastRegister + "\n" + "syscall";
            break;

        default:
            break;
    }

    RESULT = exprCode + "\n" + code;
:};


sendParameters ::= expression:e
{:

    String tipoExpr = e.toString().split(":")[2];  //se obtiene el tipo de dato de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    String codigo = ""; 

    switch(tipoExpr){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";   
            break;

        case "float":
            codigo = "s.s " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "bool":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "char":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "string":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        default:
            break;
    } 

    RESULT = e.toString().split(":")[0] + "\n" + codigo; //se genera el codigo mips
:}

| sendParameters:sp COMMA expression:e
{:
    String tipoExpr = e.toString().split(":")[2]; //se obtiene el tipo de dato de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    String codigo = "";

    switch(tipoExpr){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";   
            break;

        case "float":
            codigo = "s.s " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "bool":
            codigo = "sw " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "char":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        case "string":
            codigo = "sb " + lastRegister + ", param" + cantParams++ + "\n";
            break;

        default:
            break;
    } 

    RESULT = sp.toString() + "\n" + e.toString().split(":")[0] + "\n" + codigo; //se genera el codigo mips

:};

callFunction ::= IDENTIFIER:id LPAREN sendParameters:sp  RPAREN
{:

    String sendParams = sp.toString(); //se obtiene el codigo mips de los parametros
    ArrayList<String> paramsIds = getFuncParamsIds(tablasDeSimbolos.get(id.toString())); //se obtienen los identificadores de los parametros
    String codigo = "";

    for (int i = 0; i< paramsIds.size(); i++){ //se genera el codigo mips para los parametros
       sendParams = sendParams.replace("param"+i, paramsIds.get(i));
    }

    codigo = sendParams + "jal "+id.toString()+ ":"+ id.toString(); //se genera el codigo mips
    cantParams = 0;
    RESULT = codigo;

:};

callFunction ::= IDENTIFIER:id LPAREN RPAREN
{:
    String codigo = "jal "+id.toString()+ ":"+ id.toString(); //se genera el codigo mips
    RESULT = codigo;

:};


callFunction_statement ::= callFunction:cf ENDLINE
{:
        RESULT = cf.toString().split(":")[0]; //se genera el codigo mips
:};

return_statement ::= RETURN SEPARATOR expression:e ENDLINE
{:

    String codigo = e.toString().split(":")[0] + "\n"; //se obtiene el codigo mips de la expresion
    String move=""; 
    String tipo = e.toString().split(":")[2]; //se obtiene el tipo de dato de la expresion
    String lastRegister = e.toString().split(":")[1]; //se obtiene el ultimo registro generado
    switch(tipo){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            variables.append("return_" +currentHash+": .word 0\n"); 
            move = "sw "+lastRegister+", return_" +currentHash;
            break;
        case "float":
            variables.append("return_" +currentHash+": .float 0.0\n");
            move = "s.s "+lastRegister+", return_" +currentHash;
            break;
        case "bool":
            variables.append("return_" +currentHash+": .word 0\n");
            move = "sw "+lastRegister+", return_" +currentHash;
            break;
        case "char":
            variables.append("return_" +currentHash+": .byte 0\n");
            move = "sb "+lastRegister+", return_" +currentHash;
            break;
        case "string":
            variables.append("return_" +currentHash+": .asciiz \"\"\n");
            move = "sb "+lastRegister+", return_" +currentHash;
            break;
        default :
            break;
    }

    RESULT = codigo+"\n"+move+ "\njr $ra" ;

:}
| RETURN ENDLINE
{:
   
    String codigo = "jr $ra";
    RESULT = codigo;

:}

;
break_statement ::= BREAK ENDLINE
{:

:};


statement ::=   decl:decl {: RESULT = decl; :}
| assignment:assig {: RESULT = assig; :}
| decl_and_assignment:dcla {: RESULT = dcla; :}
| readData:rd {: RESULT = rd; :}
| printData: pd {: RESULT = pd; :}
| return_statement:rtn {: RESULT = rtn; :}
| break_statement
| callFunction_statement:cfs {: RESULT = cfs; :}
| if_struct:if_str {: RESULT = if_str; :}
| if_else_struct:if_else {: RESULT = if_else; :}
| while_struct:ws {: RESULT = ws; :}
| while_else_struct:wel {: RESULT = wel; :}
| for_range_struct:fr {: RESULT = fr; :}
| switch_struct:ss {: RESULT = ss; :};

statements ::= statement:st
{:
    RESULT = st;
:};

statements ::= statements:sts statement:st
{:

    RESULT = sts + "\n" + st;

:};

/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam
{:
     
    switch(t.toString()){ //dependiendo del tipo de dato se genera el codigo mips
        case "int":
            variables.append(idParam.toString()+": .word 0\n");
            break;
        case "float":
            variables.append(idParam.toString()+": .float 0.0\n");
            break;
        case "bool":
            variables.append(idParam.toString()+": .word 0\n");
            break;
        case "char":
            variables.append(idParam.toString()+": .byte 0\n");
            break;
        case "string":
            variables.append(idParam.toString()+": .asciiz \"\"\n");
            break;
        default :
            break;
    }
  
    //Agregar a la tabla de simbolos
    String[] symbol = new String[3]; //se crea el arreglo para agregar a la tabla de simbolos
    symbol[0] = "Parametro"; //se agrega el tipo de simbolo
    symbol[1] = idParam.toString(); //se agrega el identificador
    symbol[2] = t.toString(); //se agrega el tipo de dato
    tablasDeSimbolos.get(currentHash).add(symbol); //se agrega el simbolo a la tabla de simbolos
  
:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc
{:

    //  Definir el tipo de tabla
        String tipoTabla = "main"; //se define el tipo de tabla
        if (idFunc.toString().equals("main")){
        tipoTabla = "Tipo: main "; //se define el tipo de tabla
        }
        else{
        tipoTabla = "Tipo: funcion "; //se define el tipo de tabla
        }

    // Crear tabla de simbolos para la funcion
        currentHash = idFunc.toString(); //se obtiene el identificador de la funcion
        ArrayList<String[]> tabla = new ArrayList<>(); //se crea la tabla de simbolos
        String[] tipo = new String[2]; //se crea el arreglo para agregar a la tabla de simbolos
        tipo[0] = tipoTabla; //se agrega el tipo de simbolo
        tipo[1] = t.toString(); //se agrega el tipo de dato
        tabla.add(tipo);    //se agrega el simbolo a la tabla de simbolos
        tablasDeSimbolos.put(currentHash, tabla); //se agrega la tabla de simbolos a la tabla de simbolos global

       //Codigo MIPS
        //currentTemp = 1;
        String codigo = idFunc.toString()+":\n"; //se genera el codigo mips
        RESULT = codigo;


:};

function ::= functionIdentifier:fi LPAREN parameters RPAREN BLOCKSTART statements:st BLOCKEND
{:


    String cierreFuncion = "\nend_"+fi.toString(); //se genera el codigo mips para el cierre de la funcion
    String code = fi.toString() + st.toString() + cierreFuncion ; //se genera el codigo mips
    RESULT = code; //se genera el codigo mips

:}
| functionIdentifier:fi LPAREN  RPAREN BLOCKSTART statements:st BLOCKEND
{:
   
    String cierreFuncion = "\nend_"+fi.toString(); //se genera el codigo mips para el cierre de la funcion
    String code = fi.toString() + st.toString() + cierreFuncion; //se genera el codigo mips
    RESULT = code;

:};

functions ::= function: f {: RESULT = f; :};
functions ::= functions:fs function:f {: RESULT = fs.toString() + f.toString(); :};
functions ::= errors;


globalVariable ::=  decl:decl
{: 
    RESULT = decl; 
    
:}
| decl_and_assignment:dcla
{: 

    RESULT = dcla; 

:};

globalVariables ::= globalVariable: gv
{: 

    RESULT = gv; 
    
:}
| globalVariables:gvs globalVariable:gv
{: 
    
    RESULT = gvs.toString()+gv.toString();  //se genera el codigo mips

:};


/** PUNTO DE ENTRADA **/
program ::= globalVariables
{:

    String dataSection = ".data\n";
    String textSection = ".text\n";
    mipsCode.append(dataSection); //se genera el codigo mips
    mipsCode.append(variables.toString()); //se genera el codigo mips
    mipsCode.append(textSection); //se genera el codigo mips
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall"); //se genera el codigo mips

:}

| functions:fs
{:

    String dataSection = ".data\n"; //se genera el codigo mips
    String textSection = ".text\n"; //se genera el codigo mips
    String code = fs.toString(); //se genera el codigo mips
    mipsCode.append(dataSection); //se genera el codigo mips
    mipsCode.append(variables.toString()); //se genera el codigo mips
    mipsCode.append(textSection); //se genera el codigo mips
    mipsCode.append(code); //se genera el codigo mips
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall"); //se genera el codigo mips


:}

| globalVariables:gvs functions:fs
{:

    String dataSection = ".data\n"; //se genera el codigo mips
    String textSection = ".text\n"; //se genera el codigo mips
    String code = fs.toString(); //se genera el codigo mips
    mipsCode.append(dataSection); //se genera el codigo mips
    mipsCode.append(variables.toString()); //se genera el codigo mips
    mipsCode.append(textSection); //se genera el codigo mips
    mipsCode.append(code); //se genera el codigo mips
    mipsCode.append("\nendProgram:\nli $v0, 10 \nsyscall"); //se genera el codigo mips

:};

error_recovery ::= ERROR_RECOVERY;
errors ::= error_recovery;
errors ::= errors error_recovery;